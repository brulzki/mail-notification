/*
 * Mail Notification
 * Copyright (C) 2003-2008 Jean-Yves Lefort <jylefort@brutele.be>
 *               2022      Bruce Schultz <brulzki@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

%headertop{
#include <libsecret/secret.h>
#include "mn-mailbox.h"

typedef void (*MNGetPasswordCallback) (const gchar *password, const GError *error, gpointer data);
%}

%privateheader{
#include <gtk/gtk.h>
%}

%{
#include <glib/gi18n.h>
#if GTK_CHECK_VERSION(3,0,0)
#include <libgnome/libgnome.h>
#else
#include <libgnomeui/libgnomeui.h>
#endif
#include "mn-mailbox-private.h"
#include "mn-shell.h"
#include "mn-util.h"

typedef struct
{
  MNGetPasswordCallback callback;
  gpointer              data;
} GetPasswordData;
%}

class MN:Authenticated:Mailbox from MN:Mailbox (abstract)
{
  public char *username destroywith g_free;
  property STRING username (link, flags = MN_MAILBOX_PARAM_LOAD_SAVE | MN_MAILBOX_PARAM_REQUIRED);

  /*
   * Set when:
   *
   *   - the password is loaded from a mailboxes.xml file produced by
   *     an older version of MN
   *   - a mailbox has just been created by the properties dialog
   *     (where the user has entered a password)
   *
   * When the password is set here, it is automatically saved to the
   * keyring in added(). Is is otherwise unused (when getting the
   * password, this field is not consulted, the keyring is used
   * instead).
   */
  public char *password destroywith g_free;
  property STRING password (link, flags = MN_MAILBOX_PARAM_LOAD);

  /* last moment for subclasses to set these attributes is during seal() */
  protected char *keyring_username destroywith g_free;
  protected char *keyring_domain destroywith g_free;
  protected char *keyring_server destroywith g_free;
  protected char *keyring_protocol destroywith g_free;
  protected char *keyring_authtype destroywith g_free;
  protected int keyring_port;

  private bool _setting_password = {FALSE};
  private GCancellable *cancellable = {g_cancellable_new ()}
    destroywith g_object_unref;

  property BOOLEAN setting_password (export)
    get {
      g_value_set_boolean(VAL, selfp->_setting_password);
    };

  private gboolean checking;

  public char *runtime_password destroywith g_free;

  private GtkWidget *auth_dialog;
  protected gboolean auth_prompted;
  protected gboolean auth_cancelled; /* user pressed Cancel or mailbox removed */
  protected gboolean auth_failed;

  private gboolean prompted_password_saved = {FALSE};

  class_init (class)
  {
    /*
     * We might need to save the password to the keyring before the
     * first check, so we will call mn_mailbox_enable_checking()
     * ourselves.
     */
    MN_MAILBOX_CLASS(class)->enable_checking_when_added = FALSE;
  }

  override (MN:Mailbox) void
    seal (MNMailbox *mailbox)
  {
    Self *self = SELF(mailbox);

    PARENT_HANDLER(mailbox);

    if (self->password)
      mn_shell->mailboxes->must_save_after_load = TRUE;

    self_parse_username(self, &self->keyring_username, &self->keyring_domain);
  }

  override (MN:Mailbox) void
    added (MNMailbox *mailbox)
  {
    Self *self = SELF(mailbox);

    PARENT_HANDLER(mailbox);

    /*
     * If self->password is set, the password must be saved to the
     * keyring (either because the user has just added the mailbox or
     * because a mailboxes.xml produced by an older version of MN was
     * loaded). Checking will be enabled after the password has been
     * saved. Otherwise we must enable checking immediately.
     */
    if (self->password)
      self_set_password(self);
    else
      mn_mailbox_enable_checking(mailbox);
  }

  override (MN:Mailbox) void
    removed (MNMailbox *mailbox)
  {
    Self *self = SELF(mailbox);

    PARENT_HANDLER(mailbox);

    if (selfp->auth_dialog)
      gtk_dialog_response(GTK_DIALOG(selfp->auth_dialog), GTK_RESPONSE_CANCEL);

    // cancel any pending password requests
    g_cancellable_cancel(selfp->cancellable);

    /*
     * We do not remove the password from the keyring, since it is
     * meant to be shared with other applications
     */
  }

  private void
    set_password (self)
  {
    g_assert(self->password != NULL);
    // should not be trying to set the password while another request
    // is already in progress
    g_assert(!self->_setting_password);

    GHashTable *attributes = self_get_keyring_attributes(self);
    gchar *label = self_get_keyring_label(self);

    selfp->_setting_password = TRUE;
    secret_password_storev(SECRET_SCHEMA_COMPAT_NETWORK,
                           attributes,
			   SECRET_COLLECTION_DEFAULT,
			   label,
			   self->password,
			   selfp->cancellable,
                           self_set_password_cb,
			   self);

    g_free(label);
    g_hash_table_unref(attributes);
  }

  private void
    set_password_cb (GObject *source,
                     GAsyncResult *result,
                     gpointer data)
  {
    Self *self = data;
    GError *error = NULL;
    secret_password_store_finish (result, &error);
    selfp->_setting_password = FALSE;

    GDK_THREADS_ENTER();

    /*
     * If the mailbox has not been removed, display an error dialog if
     * the password could not be saved and enable checking.
     */
    if (mn_mailbox_get_active(MN_MAILBOX(self)))
      {
        if (error != NULL) {
          mn_show_error_dialog(NULL,
			       _("Unable to save the mailbox password"),
			       /* translators: the first %s is the mailbox format (eg: IMAP) and the second %s is the mailbox name (eg: john@imapserver.org) */
			       _("The password of %s mailbox %s could not be saved to the keyring."),
			       MN_MAILBOX(self)->format,
			       MN_MAILBOX(self)->runtime_name);
        }

	mn_mailbox_enable_checking(MN_MAILBOX(self));
      }

    /* do not call gdk_flush(), we're normally in the main thread */
    GDK_THREADS_LEAVE();

    g_error_free (error);
  }

  override (MN:Mailbox) void
    check (MNMailbox *mailbox)
  {
    Self *self = SELF(mailbox);

    if (selfp->checking)
      return;

    PARENT_HANDLER(mailbox);

    selfp->checking = TRUE;
    mn_mailbox_set_error(mailbox, NULL);

    g_object_ref(self);
    mn_thread_create((GThreadFunc) self_check_thread_cb, self);
  }

  private void
    check_thread_cb (self)
  {
    self_authenticated_check(self);

    GDK_THREADS_ENTER();

    selfp->checking = FALSE;
    g_object_unref(self);

    gdk_flush();
    GDK_THREADS_LEAVE();
  }

  virtual private void
    authenticated_check (self)
  {
    self->auth_prompted = FALSE;
    self->auth_cancelled = FALSE;
    self->auth_failed = FALSE;

    selfp->prompted_password_saved = FALSE;
  }

  protected void
    parse_username (self, char **username, char **domain)
  {
    char *at;

    at = strrchr(self->username, '@');
    if (at)
      {
	if (username)
	  *username = g_strndup(self->username, at - self->username);
	if (domain)
	  *domain = g_strdup(at + 1);
      }
    else
      {
	if (username)
	  *username = g_strdup(self->username);
	if (domain)
	  *domain = NULL;
      }
  }

  /*
   * Returns FALSE if the authentication was cancelled (either because
   * the user pressed Cancel in the password prompt dialog or because
   * the mailbox was removed).
   */
  protected gboolean
    fill_password (self, gboolean may_prompt)
  {
    self->auth_cancelled = FALSE;

    g_free(self->runtime_password);
    self->runtime_password = self_get_password_sync(self);

    /*
     * Check if the user removed the mailbox while we were waiting for
     * the keyring password.
     */
    if (! mn_mailbox_get_active(MN_MAILBOX(self)))
      {
	self->auth_cancelled = TRUE;
	return FALSE;
      }

    if (! self->runtime_password && may_prompt)
      {
	GDK_THREADS_ENTER();

	self->auth_prompted = TRUE;
        selfp->prompted_password_saved = FALSE;

	if (! self_prompt_for_password(self,
				       &self->runtime_password,
				       self->auth_failed
				       /* translators: the first %s is the mailbox format (eg: IMAP) and the second %s is the mailbox name (eg: john@imapserver.org) */
				       ? _("Mail Notification was unable to log into %s mailbox %s, possibly because the password you have entered is invalid.\n\nPlease re-enter your password.")
				       /* translators: the first %s is the mailbox format (eg: IMAP) and the second %s is the mailbox name (eg: john@imapserver.org) */
				       : _("Enter your password for %s mailbox %s."),
				       MN_MAILBOX(self)->format,
				       MN_MAILBOX(self)->runtime_name)) {
	  self->auth_cancelled = TRUE;
        }
        else {
          selfp->prompted_password_saved = TRUE;
        }

	gdk_flush();
	GDK_THREADS_LEAVE();
      }

    return ! self->auth_cancelled;
  }

  private GHashTable *
    get_keyring_attributes (self)
  {
    // secret_password_lookup_sync does not handle null values in the
    // attributes, so build a list dynamically, excluding null values
    GHashTable *attributes;
    attributes = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
    g_hash_table_insert (attributes, "user", g_strdup(self->keyring_username));
    if (self->keyring_domain) {
      g_hash_table_insert (attributes, "domain", g_strdup(self->keyring_domain));
    }
    g_hash_table_insert (attributes, "server", g_strdup(self->keyring_server));
    g_hash_table_insert (attributes, "protocol", g_strdup(self->keyring_protocol));
    if (self->keyring_authtype) {
      g_hash_table_insert (attributes, "authtype", g_strdup(self->keyring_authtype));
    }
    g_hash_table_insert (attributes, "port", g_strdup_printf ("%d", self->keyring_port));

    return attributes;
  }

  private gchar *
    get_keyring_label (self)
  {
    // user@server:port
    return g_strdup_printf("%s@%s:%d", self->keyring_username, self->keyring_server,
                           self->keyring_port);
  }

  private char *
    get_password_sync (self)
  {
    GHashTable *attributes = self_get_keyring_attributes(self);
    gchar *password = NULL;

    password = secret_password_lookupv_sync (SECRET_SCHEMA_COMPAT_NETWORK,
                          attributes,
			  selfp->cancellable,
			  NULL); // &error,

    g_hash_table_unref(attributes);
    return password;
  }

  protected void
    auth_failed (self)
  {
    /*
     * If the password had been entered at the password prompt, we
     * must remove it from the keyring since the authentication has
     * failed.
     */
    if (self->auth_prompted && selfp->prompted_password_saved)
      {
	self_delete_password(self);
        selfp->prompted_password_saved = FALSE;
      }

    self->auth_failed = TRUE;
  }

  private gboolean
    prompt_for_password (self,
			 char **password (check null),
			 const char *format (check null),
			 ...)
    attr {G_GNUC_PRINTF(3, 4)}
  {
    char *message;
    gboolean ok;

    g_return_val_if_fail(selfp->auth_dialog == NULL, FALSE);

    MN_STRDUP_VPRINTF(message, format);

    /* keep the title in sync with gnome-authentication-manager */

#if GTK_CHECK_VERSION(3,0,0)
    return FALSE;
#else
    /* translators: header capitalization */
    selfp->auth_dialog = gnome_password_dialog_new(_("Authentication Required"),
						   message,
						   self->username,
						   NULL,
						   FALSE);
    g_free(message);

    mn_add_weak_pointer(&selfp->auth_dialog);

    gnome_password_dialog_set_show_userpass_buttons(GNOME_PASSWORD_DIALOG(selfp->auth_dialog), FALSE);
    gnome_password_dialog_set_readonly_username(GNOME_PASSWORD_DIALOG(selfp->auth_dialog), TRUE);
    gnome_password_dialog_set_show_remember(GNOME_PASSWORD_DIALOG(selfp->auth_dialog), TRUE);
    gnome_password_dialog_set_remember(GNOME_PASSWORD_DIALOG(selfp->auth_dialog), GNOME_PASSWORD_DIALOG_REMEMBER_SESSION);

    ok = gnome_password_dialog_run_and_block(GNOME_PASSWORD_DIALOG(selfp->auth_dialog));
    if (ok)
      {
	GnomePasswordDialogRemember remember;

	*password = gnome_password_dialog_get_password(GNOME_PASSWORD_DIALOG(selfp->auth_dialog));

	remember = gnome_password_dialog_get_remember(GNOME_PASSWORD_DIALOG(selfp->auth_dialog));
	if (remember == GNOME_PASSWORD_DIALOG_REMEMBER_SESSION)
	  self_set_prompted_password(self, SECRET_COLLECTION_SESSION, *password);
	else if (remember == GNOME_PASSWORD_DIALOG_REMEMBER_FOREVER)
	  self_set_prompted_password(self, SECRET_COLLECTION_DEFAULT, *password);
      }

    gtk_widget_destroy(selfp->auth_dialog);

    return ok;
#endif
  }

  private void
    set_prompted_password (self,
			   const char *collection,
			   const char *password (check null))
  {
    gboolean result;
    GHashTable *attributes = self_get_keyring_attributes(self);
    gchar *label = self_get_keyring_label(self);

    /* do not block the main loop */
    gdk_flush();
    GDK_THREADS_LEAVE();

    selfp->_setting_password = FALSE;
    result = secret_password_storev_sync(SECRET_SCHEMA_COMPAT_NETWORK,
                                         attributes,
                                         collection,
                                         label,
                                         password,
                                         selfp->cancellable,
                                         NULL);
    selfp->_setting_password = TRUE;

    GDK_THREADS_ENTER();

    if (!result) {
      mn_show_error_dialog(NULL,
			   _("Unable to save the mailbox password"),
			   /* translators: the first %s is the mailbox format (eg: IMAP) and the second %s is the mailbox name (eg: john@imapserver.org) */
			   _("The password of %s mailbox %s could not be saved to the keyring."),
			   MN_MAILBOX(self)->format,
			   MN_MAILBOX(self)->runtime_name);
    }

    g_free(label);
    g_hash_table_unref(attributes);
  }

  public void
    get_password (self,
		  MNGetPasswordCallback callback,
                  GCancellable *cancellable,
		  gpointer data)
  {
    GHashTable *attributes = self_get_keyring_attributes(self);

    GetPasswordData *_data = malloc(sizeof(GetPasswordData));
    _data->callback = callback;
    _data->data = data;

    secret_password_lookupv (SECRET_SCHEMA_COMPAT_NETWORK,
                          attributes,
			  cancellable,
                          self_get_password_cb,
                          _data);
    g_hash_table_unref(attributes);
  }

  private void
    get_password_cb (GObject *source,
                     GAsyncResult *result,
                     gpointer data)
  {
    GetPasswordData *_data = data;
    GError *error = NULL;
    gchar *password = secret_password_lookup_finish (result, &error);
    _data->callback(password, error, _data->data);

    g_error_free (error);
    secret_password_free (password);
    free(_data);
  }

  private void
    delete_password (self)
  {
    gboolean result;
    GHashTable *attributes = self_get_keyring_attributes(self);

    result = secret_password_clearv_sync(SECRET_SCHEMA_COMPAT_NETWORK,
                                         attributes,
                                         selfp->cancellable,
                                         NULL);

    g_hash_table_unref(attributes);
  }
}
